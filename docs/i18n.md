# Frontend Internationalization (i18n) Documentation

## Overview

This React frontend implements a comprehensive internationalization system using `react-i18next` with TypeScript support and [i18next-cli](https://github.com/i18next/i18next-cli) automation. The system provides automatic language detection, persistent language preference, seamless integration with components, and automated translation management.

## Key Features

- **9 Language Support**: Complete translations for English, Spanish, French, German, and Portuguese variants
- **Import-based Loading**: Translation files bundled with the application for better performance
- **TypeScript Integration**: Full type safety and autocomplete for translation keys
- **CLI Automation**: [i18next-cli](https://github.com/i18next/i18next-cli) for automatic key extraction, validation, and synchronization
- **Build-time Validation**: Ensures translations are complete before deployment
- **Robust Fallback**: Default text for all translation keys prevents missing UI text
- **Consistency Testing**: Automated tests ensure all languages have matching translation keys
- **Developer Experience**: Watch mode for automatic key extraction during development

## Supported Languages

- **English (US)** - `en-US` - Default language
- **English (UK)** - `en-GB` - British English variant
- **Spanish (Spain)** - `es-ES` - European Spanish
- **Spanish (Mexico)** - `es-MX` - Mexican Spanish variant
- **French (France)** - `fr-FR` - European French
- **French (Canada)** - `fr-CA` - Canadian French variant
- **German (Germany)** - `de-DE` - Standard German
- **Portuguese (Brazil)** - `pt-BR` - Brazilian Portuguese
- **Portuguese (Portugal)** - `pt-PT` - European Portuguese

## Architecture

### File Structure

```text
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ i18n.ts                 # i18n configuration
‚îú‚îÄ‚îÄ i18n/
‚îÇ   ‚îú‚îÄ‚îÄ locales/                # Translation files (import-based)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ en-US/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # US English translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ en-GB/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # UK English translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ es-ES/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # Spanish (Spain) translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ es-MX/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # Spanish (Mexico) translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fr-FR/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # French (France) translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fr-CA/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # French (Canada) translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ de-DE/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # German translations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pt-BR/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ translation.json    # Portuguese (Brazil) translations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pt-PT/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ translation.json    # Portuguese (Portugal) translations
‚îÇ   ‚îú‚îÄ‚îÄ types.ts                # Generated TypeScript types
‚îÇ   ‚îî‚îÄ‚îÄ resources.d.ts          # Generated resource definitions
‚îî‚îÄ‚îÄ components/
    ‚îî‚îÄ‚îÄ language-switcher.tsx   # Language selection component
```

### Dependencies

```json
{
  "i18next": "^25.x.x",
  "react-i18next": "^15.x.x",
  "i18next-browser-languagedetector": "^8.x.x",
  "i18next-cli": "^1.x.x"
}
```

**Note:** We no longer use `i18next-http-backend` since we've moved to import-based loading for better TypeScript integration and build-time validation.

## Configuration

### i18n Setup (`src/lib/i18n.ts`)

```typescript
import i18n from 'i18next'
import LanguageDetector from 'i18next-browser-languagedetector'
import { initReactI18next } from 'react-i18next'

// Import all translation files
import enUS from '../i18n/locales/en-US/translation.json'
import enGB from '../i18n/locales/en-GB/translation.json'
import esES from '../i18n/locales/es-ES/translation.json'
import esMX from '../i18n/locales/es-MX/translation.json'
import frFR from '../i18n/locales/fr-FR/translation.json'
import frCA from '../i18n/locales/fr-CA/translation.json'
import deDE from '../i18n/locales/de-DE/translation.json'
import ptBR from '../i18n/locales/pt-BR/translation.json'
import ptPT from '../i18n/locales/pt-PT/translation.json'

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    fallbackLng: {
      'en-US': ['en-US', 'en'],
      'en-GB': ['en-GB', 'en'],
      'es-ES': ['es-ES', 'es'],
      'es-MX': ['es-MX', 'es'],
      'fr-FR': ['fr-FR', 'fr'],
      'fr-CA': ['fr-CA', 'fr'],
      'de-DE': ['de-DE', 'de'],
      'pt-BR': ['pt-BR', 'pt'],
      'pt-PT': ['pt-PT', 'pt'],
      default: ['en-US'],
    },
    debug: import.meta.env.DEV,

    interpolation: {
      escapeValue: false, // React already escapes values
    },

    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
    },

    resources: {
      'en-US': { translation: enUS },
      'en-GB': { translation: enGB },
      'es-ES': { translation: esES },
      'es-MX': { translation: esMX },
      'fr-FR': { translation: frFR },
      'fr-CA': { translation: frCA },
      'de-DE': { translation: deDE },
      'pt-BR': { translation: ptBR },
      'pt-PT': { translation: ptPT },
    },
  })

export default i18n
```

## Benefits of Import-based Loading

Moving from HTTP backend to import-based loading provides several advantages:

### Performance Benefits

- **Faster Loading**: Translations are bundled with the application, eliminating network requests
- **Better Caching**: Translations are cached by the browser as part of the main bundle
- **Reduced Bundle Splitting**: No need for separate translation chunks

### Developer Experience

- **TypeScript Integration**: Full type safety and autocomplete for translation keys
- **Build-time Validation**: Missing translations are caught during build
- **Better IDE Support**: IntelliSense and refactoring support for translation keys
- **Simplified Deployment**: No need to serve translation files separately

### Reliability

- **No Network Dependencies**: Translations work offline and in all environments
- **Consistent Loading**: No race conditions or loading failures
- **Version Control**: Translation changes are tracked with code changes

## CLI Tools & Automation

We use [i18next-cli](https://github.com/i18next/i18next-cli) for automated translation management. This modern CLI provides:

- **Automatic key extraction** from your codebase
- **Translation validation** and linting
- **Watch mode** for development
- **Synchronization** between languages

### Available Scripts

```bash
# Extract translation keys from your code
bun run i18n:extract

# Watch mode - automatically extract keys as you code
bun run i18n:extract:watch

# Lint translation files for issues (currently disabled)
bun run i18n:lint

# Sync translation files between languages
bun run i18n:sync
```

**Note**: The `i18n:lint` command is currently disabled due to many false positives in the existing codebase. It can be re-enabled later when more strings are properly internationalized.

### Configuration

The CLI is configured via `i18next.config.ts`:

```typescript
import { defineConfig } from 'i18next-cli'

export default defineConfig({
  locales: ['en-US', 'en-GB', 'es-ES', 'es-MX', 'fr-FR', 'fr-CA', 'de-DE', 'pt-BR', 'pt-PT'],
  extract: {
    input: [
      'src/**/*.{ts,tsx}',
      '!src/i18n/**/*', // Exclude the i18n directory itself
      '!src/**/*.test.{ts,tsx}',
      '!src/**/*.spec.{ts,tsx}',
    ],
    output: 'src/i18n/locales/{{language}}/{{namespace}}.json',
    keepRemoved: true,
    defaultValue: (locale, namespace, key) => {
      if (locale.startsWith('en')) {
        return key.split('.').pop() || key
      }
      return ''
    },
  },
  types: {
    output: 'src/i18n/types.ts',
    namespaces: ['translation'],
  },
  lint: {
    strict: true,
    missingKeys: true,
    unusedKeys: true,
  },
})
```

### TypeScript Integration

The CLI generates TypeScript types that provide:

- **Autocomplete** for translation keys
- **Compile-time validation** of key existence
- **Type safety** for translation parameters

```typescript
// ‚úÖ TypeScript will autocomplete and validate these keys
t('navigation.dashboard', 'Dashboard') // Valid
t('auth.signIn', 'Sign In') // Valid
t('invalid.key') // ‚ùå TypeScript error - key doesn't exist
```

### Language Detection Priority

The system detects language in this order:

1. **localStorage**: `i18nextLng` key (highest priority)
2. **navigator**: Browser language preference (with regional fallback)
3. **htmlTag**: `<html lang="">` attribute
4. **fallback**: `en-US` (default)

### Regional Fallback System

The system implements intelligent fallback for regional variants:

- `en-US` ‚Üí `en-US` (exact match)
- `en-GB` ‚Üí `en-GB` (exact match)  
- `en` ‚Üí `en-US` (fallback to default regional variant)
- `pt-BR` ‚Üí `pt-BR` (Brazilian Portuguese)
- `pt-PT` ‚Üí `pt-PT` (European Portuguese)
- `pt` ‚Üí `pt-BR` (fallback to primary regional variant)

### Translation File Structure

Each locale file follows this JSON structure:

```json
{
  "navigation": {
    "dashboard": "Dashboard",
    "organizations": "Organizations"
  },
  "auth": {
    "email": "Email",
    "password": "Password",
    "signIn": "Sign In",
    "emailRequired": "Email is required",
    "invalidCredentials": "Invalid email or password"
  },
  "common": {
    "loading": "Loading...",
    "save": "Save",
    "cancel": "Cancel"
  },
  "dashboard": {
    "welcome": "Welcome back, {{name}}!"
  }
}
```

## Usage in Components

### Enforced Default Text for Robust Fallback

> **Important:** All translation function calls must provide a default text as the second argument. This ensures robust fallback and prevents missing or blank UI text if a translation key is missing.

#### Example: Basic Translation (with default text)

```tsx
import { useTranslation } from 'react-i18next'

export function LoginForm() {
  const { t } = useTranslation()

  return (
    <form>
      <label>{t('auth.email', 'Email')}</label>
      <input placeholder={t('auth.emailPlaceholder', 'Enter your email')} />
      
      <label>{t('auth.password', 'Password')}</label>
      <input type="password" placeholder={t('auth.passwordPlaceholder', 'Enter your password')} />
      
      <button>{t('auth.signIn', 'Sign In')}</button>
    </form>
  )
}
```

### Translation with Variables (and default text)

```tsx
import { useTranslation } from 'react-i18next'

export function Dashboard({ userName }: { userName: string }) {
  const { t } = useTranslation()

  return (
    <div>
      <h1>{t('dashboard.welcome', 'Welcome back, {{name}}!', { name: userName })}</h1>
      <p>{t('dashboard.lastLogin', 'Last login: {{date}}', { date: new Date().toLocaleDateString() })}</p>
    </div>
  )
}
```

### Form Validation with i18n (with default text)

```tsx
import { z } from 'zod/v4'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { useTranslation } from 'react-i18next'

export function UserForm() {
  const { t } = useTranslation()

  const formSchema = z.object({
    email: z.string().email({
      message: t('auth.emailInvalid', 'Invalid email address')
    }),
    password: z
      .string()
      .min(1, t('auth.passwordRequired', 'Password is required'))
      .min(8, t('auth.passwordTooShort', 'Password must be at least 8 characters')),
  })

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  })

  // Form component JSX...
}
```

### Language Switching

```tsx
import { useTranslation } from 'react-i18next'

export function LanguageSwitcher() {
  const { i18n } = useTranslation()

  const changeLanguage = (lng: string) => {
    i18n.changeLanguage(lng)
  }

  return (
    <select 
      value={i18n.language} 
      onChange={(e) => changeLanguage(e.target.value)}
    >
      <option value="en">English</option>
      <option value="es">Espa√±ol</option>
      <option value="fr">Fran√ßais</option>
      <option value="de">Deutsch</option>
      <option value="pt">Portugu√™s</option>
    </select>
  )
}
```

### Conditional Rendering Based on Language

```tsx
import { useTranslation } from 'react-i18next'

export function CultureSpecificContent() {
  const { i18n } = useTranslation()

  return (
    <div>
      {i18n.language === 'en' && (
        <div>English-specific content</div>
      )}
      {i18n.language === 'es' && (
        <div>Contenido espec√≠fico en espa√±ol</div>
      )}
    </div>
  )
}
```

## Creating New Components with i18n

### 1. Basic Component Template

```tsx
import { useTranslation } from 'react-i18next'

interface MyComponentProps {
  // Define your props
}

export function MyComponent({ ...props }: MyComponentProps) {
  const { t } = useTranslation()

  return (
    <div>
      <h1>{t('myComponent.title')}</h1>
      <p>{t('myComponent.description')}</p>
    </div>
  )
}
```

### 2. Add Translations to All Locale Files

In `public/locales/en/translation.json`:

```json
{
  "myComponent": {
    "title": "My Component Title",
    "description": "This is my component description"
  }
}
```

In `public/locales/es/translation.json`:

```json
{
  "myComponent": {
    "title": "T√≠tulo de Mi Componente",
    "description": "Esta es la descripci√≥n de mi componente"
  }
}
```

### 3. Complex Component with Multiple Features

```tsx
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'

export function UserManagement() {
  const { t } = useTranslation()
  const [loading, setLoading] = useState(false)

  const handleSave = async () => {
    setLoading(true)
    try {
      // Save logic here
      toast.success(t('user.saveSuccess'))
    } catch (error) {
      toast.error(t('user.saveError'))
    } finally {
      setLoading(false)
    }
  }

  return (
    <div>
      <h1>{t('user.management.title')}</h1>
      
      <button onClick={handleSave} disabled={loading}>
        {loading ? t('common.loading') : t('common.save')}
      </button>
      
      <div className="status">
        {loading && t('user.saving')}
      </div>
    </div>
  )
}
```

## Creating New Pages with i18n

### 1. Page Component Template

```tsx
import { useTranslation } from 'react-i18next'
import { Helmet } from 'react-helmet-async'

export function AboutPage() {
  const { t } = useTranslation()

  return (
    <>
      <Helmet>
        <title>{t('about.pageTitle')}</title>
        <meta name="description" content={t('about.pageDescription')} />
      </Helmet>
      
      <div className="container mx-auto px-4 py-8">
        <h1>{t('about.title')}</h1>
        <p>{t('about.introduction')}</p>
        
        <section>
          <h2>{t('about.mission.title')}</h2>
          <p>{t('about.mission.description')}</p>
        </section>
      </div>
    </>
  )
}
```

### 2. Add Page Translations

```json
{
  "about": {
    "pageTitle": "About Us - Your App Name",
    "pageDescription": "Learn more about our company and mission",
    "title": "About Us",
    "introduction": "Welcome to our company...",
    "mission": {
      "title": "Our Mission",
      "description": "We strive to..."
    }
  }
}
```

### 3. Dynamic Route with i18n

```tsx
import { useParams } from '@tanstack/react-router'
import { useTranslation } from 'react-i18next'

export function ProductDetailPage() {
  const { productId } = useParams()
  const { t } = useTranslation()

  return (
    <div>
      <h1>{t('product.details.title', { id: productId })}</h1>
      <p>{t('product.details.description')}</p>
    </div>
  )
}
```

## Advanced Patterns

### 1. Namespaces (Multiple Translation Files)

```typescript
// i18n.ts configuration with namespaces
i18n.init({
  ns: ['translation', 'validation', 'errors'],
  defaultNS: 'translation',
  // ... other config
})
```

Usage in components:

```tsx
const { t } = useTranslation(['translation', 'validation'])

// Use specific namespace
t('validation:emailRequired')
t('errors:networkError')
```

### 2. Lazy Loading Translations

```tsx
import { Suspense } from 'react'
import { useTranslation } from 'react-i18next'

function MyLazyComponent() {
  const { t, ready } = useTranslation()

  if (!ready) return <div>Loading translations...</div>

  return <div>{t('myComponent.title')}</div>
}

export function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MyLazyComponent />
    </Suspense>
  )
}
```

### 3. Format Numbers and Dates

```tsx
import { useTranslation } from 'react-i18next'

export function LocalizedContent() {
  const { t, i18n } = useTranslation()

  const formatPrice = (amount: number) => {
    return new Intl.NumberFormat(i18n.language, {
      style: 'currency',
      currency: 'USD'
    }).format(amount)
  }

  const formatDate = (date: Date) => {
    return new Intl.DateTimeFormat(i18n.language).format(date)
  }

  return (
    <div>
      <p>{t('product.price')}: {formatPrice(29.99)}</p>
      <p>{t('product.releaseDate')}: {formatDate(new Date())}</p>
    </div>
  )
}
```

### 4. Pluralization

```tsx
import { useTranslation } from 'react-i18next'

export function ItemCounter({ count }: { count: number }) {
  const { t } = useTranslation()

  return (
    <div>
      {t('items.count', { count, defaultValue_one: '{{count}} item', defaultValue_other: '{{count}} items' })}
    </div>
  )
}
```

Translation file structure for pluralization:

```json
{
  "items": {
    "count_one": "{{count}} item",
    "count_other": "{{count}} items"
  }
}
```

## Adding New Languages

### 1. Create Translation Files

Create new translation files in `public/locales/`:

```bash
mkdir public/locales/ja
touch public/locales/ja/translation.json
```

### 2. Add Complete Translations

Copy the structure from `en/translation.json` and translate all values:

```json
{
  "navigation": {
    "dashboard": "„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ",
    "organizations": "ÁµÑÁπî"
  },
  "auth": {
    "email": "„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ",
    "password": "„Éë„Çπ„ÉØ„Éº„Éâ"
  }
}
```

### 3. Update Language Switcher

```tsx
export function LanguageSwitcher() {
  const { i18n } = useTranslation()

  const languages = [
    { code: 'en', name: 'English' },
    { code: 'es', name: 'Espa√±ol' },
    { code: 'fr', name: 'Fran√ßais' },
    { code: 'de', name: 'Deutsch' },
    { code: 'pt', name: 'Portugu√™s' },
    { code: 'ja', name: 'Êó•Êú¨Ë™û' }, // Add new language
  ]

  return (
    <select 
      value={i18n.language} 
      onChange={(e) => i18n.changeLanguage(e.target.value)}
    >
      {languages.map(lang => (
        <option key={lang.code} value={lang.code}>
          {lang.name}
        </option>
      ))}
    </select>
  )
}
```

## Translation Key Organization

### Recommended Key Structure

```text
feature.component.element
```

Examples:

```json
{
  "auth.signIn.title": "Sign In",
  "auth.signIn.submitButton": "Sign In",
  "auth.signUp.title": "Create Account",
  "dashboard.stats.totalUsers": "Total Users",
  "settings.profile.updateButton": "Update Profile"
}
```

### Common Categories

```json
{
  "navigation": {}, // Navigation menu items
  "auth": {},        // Authentication related
  "common": {},      // Shared UI elements
  "errors": {},      // Error messages
  "validation": {},  // Form validation
  "dashboard": {},   // Dashboard specific
  "settings": {},    // Settings page
  "organizations": {}, // Organization management
  "billing": {}      // Billing and payments
}
```

## Form Integration

### React Hook Form with Validation

```tsx
import { z } from 'zod/v4'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { useTranslation } from 'react-i18next'
import { Form, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'

export function ContactForm() {
  const { t } = useTranslation()

  const formSchema = z.object({
    name: z.string().min(1, t('validation.nameRequired')),
    email: z.string().email(t('validation.emailInvalid')),
    message: z.string().min(10, t('validation.messageMinLength'))
  })

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema)
  })

  const onSubmit = (values: z.infer<typeof formSchema>) => {
    // Handle form submission
    console.log(values)
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>{t('contact.form.name')}</FormLabel>
              <FormControl>
                <Input 
                  placeholder={t('contact.form.namePlaceholder')} 
                  {...field} 
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button type="submit">
          {t('contact.form.submit')}
        </Button>
      </form>
    </Form>
  )
}
```

## Error Handling with i18n

### API Error Messages

```tsx
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'

export function useApiErrorHandler() {
  const { t } = useTranslation()

  const handleError = (error: any) => {
    const errorCode = error?.response?.data?.code || 'unknown'
    const errorMessage = t(`errors.api.${errorCode}`, {
      defaultValue: t('errors.api.generic')
    })
    
    toast.error(errorMessage)
  }

  return { handleError }
}
```

Error translations:

```json
{
  "errors": {
    "api": {
      "generic": "An error occurred. Please try again.",
      "network": "Network error. Check your connection.",
      "unauthorized": "You are not authorized to perform this action.",
      "forbidden": "Access denied.",
      "notFound": "The requested resource was not found.",
      "validationError": "Please check your input and try again."
    }
  }
}
```

## Testing i18n Components

### Jest Testing

```tsx
import { render, screen } from '@testing-library/react'
import { I18nextProvider } from 'react-i18next'
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import { MyComponent } from './MyComponent'

// Setup test i18n instance
i18n.use(initReactI18next).init({
  lng: 'en',
  fallbackLng: 'en',
  resources: {
    en: {
      translation: {
        'myComponent.title': 'Test Title'
      }
    }
  }
})

const renderWithI18n = (component: React.ReactElement) => {
  return render(
    <I18nextProvider i18n={i18n}>
      {component}
    </I18nextProvider>
  )
}

test('renders translated text', () => {
  renderWithI18n(<MyComponent />)
  expect(screen.getByText('Test Title')).toBeInTheDocument()
})
```

## Performance Optimization

### Bundle Splitting for Translations

```typescript
// i18n.ts
i18n.init({
  backend: {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    allowMultiLoading: false, // Load one namespace at a time
  },
  // Only load current language
  preload: [], // Don't preload languages
})
```

### Lazy Loading Components

```tsx
import { lazy, Suspense } from 'react'
import { useTranslation } from 'react-i18next'

const LazyAdminPanel = lazy(() => import('./AdminPanel'))

export function App() {
  const { t } = useTranslation()

  return (
    <Suspense fallback={<div>{t('common.loading')}</div>}>
      <LazyAdminPanel />
    </Suspense>
  )
}
```

## Best Practices

### 1. Key Naming Conventions

- Use lowercase with dots for hierarchy: `auth.form.emailLabel`
- Be descriptive: `button.save` not `btn.sv`
- Group related keys: `validation.email.required`, `validation.email.invalid`

### 2. Variable Handling

```tsx
// Good: Clear variable names
t('welcome.message', { userName: 'John', loginCount: 5 })

// Bad: Unclear variables
t('welcome.message', { u: 'John', c: 5 })
```

### 3. Default Values (Required)

```tsx
// Always provide a default text as the second argument
t('feature.newKey', 'Default text for new feature')
```

### 4. Avoid Hardcoded Text

```tsx
// Bad
<button>Save</button>

// Good (with default text)
<button>{t('common.save', 'Save')}</button>
```

### 5. Context-Specific Translations

```tsx
// Different contexts might need different translations
t('button.save.form')     // "Save"
t('button.save.document') // "Save Document"
t('button.save.draft')    // "Save as Draft"
```

## Robust Fallback Handling

All translation usages in the codebase are required to provide a default text argument. This ensures:

- No UI text will be missing if a translation key is absent.
- Developers and testers always see meaningful fallback text during development.
- The app is robust to incomplete or missing translation files.

If you see a translation call without a default text, update it to include one as the second argument.

## Troubleshooting

### Common Issues

1. **Translation not updating**: Clear localStorage and refresh
2. **Missing translations**: With default text, UI will show fallback; check console for missing key warnings
3. **Interpolation not working**: Ensure variables are passed correctly
4. **Language not persisting**: Check localStorage implementation

### Debug Mode

Enable debug mode in development:

```typescript
i18n.init({
  debug: import.meta.env.DEV,
  // ... other config
})
```

This will log missing translations and other helpful information to the console.

## Migration from HTTP Backend

If you're migrating from the old `public/locales` structure, here's what changed:

### What Was Removed

- `i18next-http-backend` dependency
- `public/locales/` directory
- HTTP-based translation loading

### What Was Added

- `i18next-cli` for automation
- `src/i18n/locales/` directory
- Import-based translation loading
- TypeScript type definitions

### Migration Steps

1. **Move translation files**: `public/locales/` ‚Üí `src/i18n/locales/`
2. **Update i18n config**: Replace `Backend` with direct imports
3. **Install CLI**: `bun add -D i18next-cli`
4. **Update imports**: Change any direct imports to use new paths
5. **Test build**: Ensure everything works with `bun run build`

### Benefits of Migration

- **Better Performance**: No network requests for translations
- **Type Safety**: Full TypeScript support for translation keys
- **Build Validation**: Missing translations caught at build time
- **Simplified Deployment**: No need to serve translation files separately

## Troubleshooting

### Common Issues

1. **Translation not updating**: Clear localStorage and refresh
2. **Missing translations**: With default text, UI will show fallback; check console for missing key warnings
3. **Interpolation not working**: Ensure variables are passed correctly
4. **Language not persisting**: Check localStorage implementation
5. **Build errors**: Ensure all translation files are properly imported in `i18n.ts`

### Debug Mode

Enable debug mode in development:

```typescript
i18n.init({
  debug: import.meta.env.DEV,
  // ... other config
})
```

This will log missing translations and other helpful information to the console.

## Best Practices Summary

1. **Always provide default text** for all translation calls
2. **Use the CLI** for key extraction and validation
3. **Keep translations organized** with clear naming conventions
4. **Test all languages** to ensure consistency
5. **Use TypeScript** for better development experience

## Current Status & Future Improvements

### ‚úÖ Completed

- Migration from HTTP backend to import-based loading
- CLI integration with i18next-cli
- TypeScript type definitions
- Automated testing for translation consistency
- Comprehensive documentation

### üöß In Progress

- Gradual internationalization of existing hardcoded strings
- Optimization of translation key organization

### üîÆ Future Enhancements

- Re-enable linting when more strings are internationalized
- Add translation management integration (e.g., with translation services)
- Implement dynamic language loading for better performance
- Add translation key validation in CI/CD pipeline

## Quick Reference

### Essential Commands

```bash
# Start development with auto-extraction
bun run i18n:extract:watch

# Extract keys after adding new translations
bun run i18n:extract

# Test translation consistency
bun test
```

### Best Practices

1. **Always provide default text** for translation calls
2. **Use descriptive key names** following the pattern `feature.component.element`
3. **Test all languages** to ensure consistency
4. **Use the CLI** for key extraction and validation
5. **Keep translations organized** with clear naming conventions

This documentation provides a complete guide for implementing and extending the i18n system in your React frontend with TypeScript. All translation usages must now include a default text for robust fallback.
